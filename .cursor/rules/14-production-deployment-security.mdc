# Production Deployment - Resource Limits & Security

## Overview

This document defines mandatory rules for **resource limits and security** in production deployments. This includes ResourceQuota, LimitRange, SecurityContext, image security, and secrets management.

**MANDATORY**: All production deployments MUST follow these security rules.

## 1. Resource Quotas

**MANDATORY**: Set ResourceQuota for each namespace.

**Production ResourceQuota Example**:
```yaml
# templates/resourcequota.yaml
apiVersion: v1
kind: ResourceQuota
metadata:
  name: {{ include "aether-defense.fullname" . }}-quota
spec:
  hard:
    requests.cpu: "20"
    requests.memory: 40Gi
    limits.cpu: "40"
    limits.memory: 80Gi
    persistentvolumeclaims: "10"
    pods: "50"
```

## 2. Limit Ranges

**MANDATORY**: Set LimitRange to enforce default resource limits.

```yaml
# templates/limitrange.yaml
apiVersion: v1
kind: LimitRange
metadata:
  name: {{ include "aether-defense.fullname" . }}-limits
spec:
  limits:
  - default:
      cpu: "500m"
      memory: "512Mi"
    defaultRequest:
      cpu: "100m"
      memory: "128Mi"
    type: Container
```

## 3. Security Context

**MANDATORY**: Configure SecurityContext for all containers.

**Security Requirements**:
- ✅ **ALWAYS** run as non-root user (`runAsNonRoot: true`)
- ✅ **ALWAYS** set `runAsUser` to specific UID (e.g., 1000)
- ✅ **ALWAYS** use read-only root filesystem when possible
- ✅ **ALWAYS** drop all capabilities, add only required ones
- ✅ **ALWAYS** set `allowPrivilegeEscalation: false`

**Implementation**:
```yaml
# In deployment.yaml
spec:
  securityContext:
    runAsNonRoot: true
    runAsUser: 1000
    fsGroup: 1000
    seccompProfile:
      type: RuntimeDefault
  containers:
  - name: user-api
    securityContext:
      allowPrivilegeEscalation: false
      readOnlyRootFilesystem: true
      capabilities:
        drop:
        - ALL
        add:
        - NET_BIND_SERVICE  # Only if needed for port < 1024
      runAsNonRoot: true
      runAsUser: 1000
    volumeMounts:
    - name: tmp
      mountPath: /tmp
    - name: var-run
      mountPath: /var/run
  volumes:
  - name: tmp
    emptyDir: {}
  - name: var-run
    emptyDir: {}
```

## 4. Image Security

**MANDATORY**: Follow image security best practices.

**Rules**:
- ✅ **ALWAYS** use specific image tags (never `latest` in production)
- ✅ **ALWAYS** scan images for vulnerabilities before deployment
- ✅ **ALWAYS** use imagePullPolicy: `IfNotPresent` or `Always`
- ✅ **ALWAYS** pull from trusted registries only
- ✅ **NEVER** use images from untrusted sources

**Values Configuration**:
```yaml
global:
  imageRegistry: "registry.example.com"
  imagePullSecrets:
    - name: registry-secret

userApi:
  image:
    repository: aether-defense/user-api
    tag: "v1.2.3"  # Specific version, not "latest"
    pullPolicy: Always
```

## 5. Secrets Management

**MANDATORY**: Use Kubernetes Secrets or external secret management.

**Rules**:
- ✅ **NEVER** hardcode secrets in values.yaml or templates
- ✅ **ALWAYS** use Kubernetes Secrets or external secret managers (e.g., Vault, Sealed Secrets)
- ✅ **ALWAYS** encrypt secrets at rest
- ✅ **ALWAYS** rotate secrets regularly

**Implementation**:
```yaml
# Use external-secrets operator or similar
apiVersion: external-secrets.io/v1beta1
kind: ExternalSecret
metadata:
  name: {{ include "aether-defense.fullname" . }}-secrets
spec:
  secretStoreRef:
    name: vault-backend
    kind: SecretStore
  target:
    name: {{ include "aether-defense.fullname" . }}-secrets
  data:
  - secretKey: database-password
    remoteRef:
      key: aether-defense/database
      property: password
```

## Important Rules Summary

1. **ALWAYS** set ResourceQuota and LimitRange
2. **ALWAYS** configure SecurityContext (runAsNonRoot, readOnlyRootFilesystem)
3. **ALWAYS** use specific image tags (never "latest")
4. **ALWAYS** scan images for vulnerabilities
5. **ALWAYS** use external secret management
6. **NEVER** hardcode secrets
7. **NEVER** use untrusted image sources
